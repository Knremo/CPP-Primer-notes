# 1. C++98 的执行顺序问题
* 编译器没有义务一定按代码里给出的顺序产生代码
* 在多处理器架构中，各个处理器可能存在缓存不一致性问题

x86 使用的内存模型基本提供了顺序一致性（sequential consistency）

ARM 使用的内存模型就只是松散一致性（relaxed consistency）

**volatile**

由于 volatile 不能在多处理器的环境下确保多个线程能看到同样顺序的数据变化，在今天的通用应用程序中，不应该再看到 volatile 的出现。

# 2. C++11 的内存模型
现在我们有了原子对象（atomic）和使用原子对象的获得（acquire）、释放（release）语义，可以真正精确地控制内存访问的顺序性，保证我们需要的内存序

* **获得**是一个对内存的读操作，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去。
* **释放**是一个对内存的写操作，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去。

结果只能是 1、2 或 3、4，即满足完全存储序（total store ordering）
```c++
int x = 0;
atomic<int> y = 0;

// thread 1
x = 1;
y.store(2, memory_order_release);

// thread 2
if (y.load(memory_order_acquire) == 2) {
    x = 3;
    y.store(4, memory_order_relaxed); // 存储只需要松散内存序
}
```

 atomic 变量的写操作缺省就是释放语义，读操作缺省就是获得语义.但是，缺省行为可能是对性能不利的：我们并不需要在任何情况下都保证操作的顺序性。

 # 3. atomic
对于整型量和指针等简单类型，通常结果是无锁的原子对象；

而对于另外一些类型，的类型，编译器会自动为这些原子对象的操作加上锁。

编译器提供了一个原子对象的成员函数 `is_lock_free`，可以检查这个原子对象上的操作是否是无锁的。

原子操作有三类：
* 读：在读取的过程中，读取位置的内容不会发生任何变动。
* 写：在写入的过程中，其他执行线程不会看到部分写入的结果。
* 读‐修改‐写：读取内存、修改数值、然后写回内存，整个操作的过程中间不会有其他写入操作插入，其他执行线程不会看到部分写入的结果。

`<atomic>` 头文件中还定义了内存序，分别是：
* memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的
* memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见
* memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见
* memory_order_acq_rel：获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见
* memory_order_seq_cst：顺序一致性语义，对于读操作相当于获取，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，**是所有原子操作的默认内存序**

atomic 有下面这些常用的成员函数：
* 默认构造函数(只支持零初始化)
* 拷贝构造函数被删除
* 使用内置对象类型的构造函数（不是原子操作）
* 可以从内置对象类型赋值到原子对象（相当于 store）
* 可以从原子对象隐式转换成内置对象（相当于 load）
* store，写入对象到原子对象里，第二个可选参数是内存序类型
* load，从原子对象读取内置对象，有个可选参数是内存序类型
* is_lock_free，判断对原子对象的操作是否无锁（是否可以用处理器的指令直接完成原子操作）
* exchange，交换操作，第二个可选参数是内存序类型（这是读‐修改‐写操作）
* compare_exchange_weak 和 compare_exchange_strong，两个比较加交换（CAS）的版本，你可以分别指定成功和失败时的内存序，也可以只指定一个，或使用默认的最安全内存序（这是读‐修改‐写操作）
* fetch_add 和 fetch_sub，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回其原始值，第二个可选参数是内存序类型（这是读‐修改‐写操作）
* ++ 和 --（前置和后置），仅对整数和指针内置对象有效，对目标原子对象执行增一或减一，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）
* += 和 -=，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回操作之后的数值，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）

